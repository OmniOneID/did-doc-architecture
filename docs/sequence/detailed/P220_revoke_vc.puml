@startuml P220_revoke_vc

'- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
' Configuration
'- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
'=== Header and Footer ===
header OPEN-DID Technical Specification
footer
  	Page %page% of %lastpage% at %date("yyyy-MM-dd hh:mm:ss")
end footer

'=== Title ===
title
	<size:25>P220: VC Revocation</size>
end title

'=== Options ===
' Autonumbering: e.g., "<b>000." => Display a 3-digit number with leading zeros
autonumber "<b>(#)</b>"
' Hide the participant box at the bottom of the page
'hide footbox

'=== Constants ===

!$refdoc = "Refer to a separate document"
!$doc = "Refer to data specification document"

'=== Participants ===
skinparam ParticipantPadding 20
skinparam BoxPadding 20
skinparam MaxMessageSize 500
skinparam MinClassWidth 80

actor "**User**" as user
box Mobile #OldLace
    participant "**Wallet**" as wal <<Wallet>>
    participant "**Certified App**" as ca <<App>>
end box
participant "**TAS**" as tas <<Server>>
participant "**Issuer**" as vf <<Server>>

box Trust Repository
    participant "**blockchain**" as BC <<Storage>> #WhiteSmoke
end box

|||
== P220-1: Propose Revoke VC ==

activate ca

ca -> tas ++: Propose Revoke VC\n{vcId}
    tas <-> BC: Retrieve VC Meta
    tas -> tas: Confirm Issuer DID
    tas -> vf ++: Inspect Propose Revoke\n{vcId}
    note right
        Identification of the issuing issuer is done by checking the TAS DB or
        information stored in internal settings.
    end note
        vf -> vf: Check if VC revocation is possible
        vf -> vf: issuerNonce = Generate nonce for user signature verification
        vf -> vf: authType: Retrieve user authentication method
    return {issuerNonce, authType}
return {issuerNonce, authType}

|||
== P220-2: Request ECDH ==

ca -> wal: Retrieve DID
return {Holder DID}
ca -> ca: Generate Client Nonce
ca -> ca: Generate DH Key Pair
ca -> ca: Prepare ECDH Request\
            \n* (ReqEcdh)reqEcdh\
            \n   = Create ECDH request

rnote right of ca #MintCream
    **ReqEcdh** : $doc  
    client|clientNonce|curve|publicKey|candidate
end note

opt KeyAgreement Signature ON
    ca -> wal ++: Request KeyAgreement Signature\n{reqEcdh}
        wal -> wal: signKeyAgree(reqEcdh)
        note right
            During the actual call:
            * The certified app provides the hash of the original text and the keyId
            * The wallet responds with only the signature value
        end note
    return {reqEcdh}
    rnote right of wal #MintCream
        **signedReqEcdh** : $doc
        client|clientNonce|curve|publicKey|candidate|Proof  
        Proof = KeyAgreeProof
    end note
end



ca -> tas++ : ECDH Request
rnote right of ca #Lavender
    **[REQ : ECDH Request]**
    body : 
        messageId
        txId
        reqEcdh
end note

    opt KeyAgreement Signature ON
        tas -> tas: Verify reqEcdh.proof signature
    end

    tas -> tas : Validate reqEcdh format
    tas -> tas : Generate Server Nonce
    tas -> tas : Generate mergedNonce
    rnote right of tas #MintCream
        **mergedNonce**
        sha256(serverNonce, clientNonce)
    end note
    tas -> tas: Generate DH Key Pair

    tas -> tas: Perform ECDH\
                \n* sesKey = Session Key\

    rnote right of tas #MintCream
        **sesKey**
        ecies(serverPriKey|clientPubKey|mergedNonce|cipherAlg)
    end note
    tas -> tas: Generate ECDH Accept Data\
                \n* (AccEcdh)accEcdh
    rnote right of tas #MintCream
        **accEcdh** : $doc
        server|serverNonce|cipher|publicKey|padding
    end note
    opt KeyAgreement Signature ON
        tas -> tas: signKeyAgree(accEcdh)
    end

return ECDH Response
rnote right of ca #Lavender
    **[RES : ECDH Response]**
    body : 
        txId
        accEcdh
end note

opt KeyAgreement Signature ON
    ca -> ca: Verify accEcdh.proof signature
end
ca -> ca : Validate accEcdh format
ca -> ca : Generate mergedNonce
rnote right of ca #MintCream
    **mergedNonce**
    sha256(serverNonce, clientNonce)
end note
ca -> ca: Perform ECDH\n* sesKey = Session Key

rnote right of ca #MintCream
    **sesKey**
    ecies(clientPriKey|serverPubKey|mergedNonce|cipherAlg)
end note



|||
== P220-3: Request Create Token ==

hnote over ca, wal #LimeGreen
    * purpose = "RevokeVc"
    * (SignedWalletInfo)walletInfo = Generate wallet information
    * walletToken = Wallet token
end hnote

ca -> ca: * (AttestedAppInfo)caAppInfo\
        \n   = Generate signed app information
ca -> ca: Generate server token seed\
        \n* (ServerTokenSeed)seed = {\
        \n     purpose = "RevokeVc",\
        \n     walletInfo,\
        \n     caAppInfo\
        \n  }

ca -> tas ++: Request Create Token\n{seed}
    tas -> tas: Verify signatures\
            \n* Verify wallet signature\
            \n* Verify certified app provider signature
    tas -> tas: Generate and store server token\
            \n* Generate (ServerTokenData)std\
            \n* serverToken = sha256(std)
    tas -> tas: Encrypt response information\
            \n* iv = Generate IV\
            \n* tmp = enc(std, sesKey, iv)\
            \n* encStd = multibase(tmp)
return {iv, encStd}

ca -> ca: Decrypt (omitted) and prepare data\
        \n* Calculate serverToken


|||
== P220-4: Request Revoke VC ==
ca -> wal ++: Request Revoke VC\n{walletToken, serverToken, vcId,\
        \n issuerNonce, authType}
    wal -> wal: Validate walletToken
    wal -> wal: Validate vcId and issuerNonce
    wal -> wal: Prepare ReqRevokeVc data\
        \n* (ReqRevokeVc)reqRevokeVc = {\
        \n     vcId = Revoke VC ID,\
        \n     issuerNonce\
        \n  }
    user -[#Blue]\ wal: User authentication (non-standard)
    wal -> wal: signAuth(reqRevokeVc)
    wal -> tas ++: Request Revoke VC\n{serverToken, reqRevokeVc}
        tas -> tas: Validate serverToken
        tas -> vf ++: Revoke VC\n{reqRevokeVc}
            vf -> vf: Validate issuerNonce
            vf <-> BC: Retrieve Holder DID Doc
            vf -> vf: Verify reqRevokeVc signature
            vf -> BC++: Request VC status update
            return {result}
        return {result}
    return {result}
return {result}
ca -> wal: request delete VC {walletToken, vcId}
wal -> wal: delete VC
opt include ZKP
    wal -> wal: delete ZKP Credential
end

|||
== P220-5: Confirm Revoke VC ==

ca -> tas ++: Confirm Revoke VC
    tas -> vf ++: Complete Revoke VC
    return OK
return OK

|||
|||
@enduml